[{"title":"react的受控组件和非受控组件","date":"2017-02-06T08:40:17.447Z","path":"2017/02/06/react_Component/","text":"背景 React内部分别使用了props, state来区分组件的属性和状态。props用来定义组件外部传进来的属性,属于那种经过外部定义之后, 组件内部就无法改变。而state维持组件内部的状态更新和变化, 组件渲染出来后响应用户的一些操作,更新组件的一些状态。如果组件内部状态不需要更新,即没有调用过this.setState,全部通过props来渲染也是没问题的, 不过这种情况不常见。本文所介绍的内容就是通过props和state的定义来谈谈React的受控组件和非受控组件 react的非受控组件 顾名思义, 非受控组件即组件的状态改变不受控制.接来下我们以一个简单input组件代码来描述。 123456789101112import React, &#123; Component &#125; from 'react';import ReactDOM from 'react-dom';class Demo1 extends Component &#123; render() &#123; return ( &lt;input /&gt; ) &#125;&#125;ReactDOM.render(&lt;Demo1/&gt;, document.getElementById('content')) 在这个最简单的输入框组件里,我们并没有干涉input中的value展示,即用户输入的内容都会展示在上面。如果我们通过props给组件设置一个初始默认值,defaultValue属性是React内部实现的一个属性,目的类似于input的placeholder属性。ps: 此处如果使用value代替defaultValue,会发现输入框的值无法改变。 react的受控组件 上面提到过,既然通过设置input的value属性, 无法改变输入框值,那么我们把它和state结合在一起,再绑定onChange事件,实时更新value值就行了 123456789101112131415161718192021class Demo1 extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: props.value &#125; &#125; handleChange(e) &#123; this.setState(&#123; value: e.target.value &#125;) &#125; render() &#123; return ( &lt;input value=&#123;this.state.value&#125; onChange=&#123;e =&gt; this.handleChange(e)&#125;/&gt; ) &#125;&#125; 这就是最简单的受控组件模型, 我们可以通过在onChange的回调里控制input要显示的值,例如我们设置input框只能输入数字 1234this.setState(&#123; value: e.target.value.replace(/\\D/g, '')&#125;)","tags":[{"name":"react的受控组件 react非受控组件","slug":"react的受控组件-react非受控组件","permalink":"http://yoursite.com/tags/react的受控组件-react非受控组件/"}]},{"title":"Hello World","date":"2017-02-04T01:12:14.245Z","path":"2017/02/04/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]},{"title":"angular.js的几个问题","date":"2017-02-04T01:12:14.245Z","path":"2017/02/04/demo/","text":"一、ng-show,ng-hide和ng-if的区别？ ng-show和ng-hide是通过display:none的方式将元素隐藏的，而ng-if是通过删除所在节点的方式将元素隐藏的，相对来说 ng-if的方式更好，提高了性能 二、angular中的digest周期是什么？ 每个digest周期中，angular总会对比scope上model的值，一般digest周期都是自动触发的，我们也可以使用$apply或者$digest进行手动触发 三、模块之间的通讯方式？ 1.server 自定义服务，在其他的模块中引入这个服务，就可以让这个模块使用你自定义服务中的功能 2.使用$rootScope 通俗来新疆$rootScope是所有$scope的父亲；另外angular解析页面的时候，也是先通过ng-app指令创建一个$rootScope继续解析，将双花括号表达式解析成变量，接着会解析ng-controller所在的节点指向到某个controller函数，这个时候在这个controller函数中变成一个$scope对象，所以我们直接将变量挂载到$rootScope上后，所有模块都可以引用这个变量 3.controller之间使用广播的方式 广播的方式即使用$emit、$on、$broadcast 三个函数比如下例：123456789101112&lt;body ng-app=\"app\"&gt; &lt;div ng-controller=\"demo1\"&gt; &lt;button ng-click=\"broadcast()\"&gt;向子控制器传递&lt;/button&gt; &lt;div ng-controller=\"demo2\"&gt; &lt;/div&gt; &lt;div&gt; &lt;div ng-controller=\"demo3\"&gt; &lt;button ng-click=\"emit()\"&gt;向父亲传递信息&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt; 在demo2,demo3中使用$emit函数可以向父控制器demo1中发送数据，而demo1通过$on接收发送过来的数据，反之则用$broadcast通信 4.怎么停止$watch()？ 启动一个$watch()会返回一个停止的函数，启动这个函数就会停止","tags":[{"name":"angular angular面试","slug":"angular-angular面试","permalink":"http://yoursite.com/tags/angular-angular面试/"}]},{"title":"web前端面试问题记录","date":"2017-02-04T01:12:14.245Z","path":"2017/02/04/web-mianshi/","text":"1.怎么理解js面向对象？ js是否面向对象，这个问题可以先说什么是面向对象，面向对象的语言都有共同的特征那就是有类的概念，每个类都有抽象、封装、继承、多态的特性，而js在ES6之前并没有类的概念，但是，他却可以利用构造函数来实现类所能做的事情，并通过原型链实现继承，那么它同样也具备了以上面向对象语言的所有特征，特别的，ES6新增加了class这一概念，就更说明了其是一种面向对象的语言，所以js是一种面向对象的语言 2.bind和on的区别？ on可以过滤指定元素，bind不可以 3.bootstrap的栅格系统，应用场景 bootstrap是如今最流行的前端框架之一，可以使web网页开发的更加快速bootstrap主要应用于需要响应式布局的网站，可以适用于不同大小的设备；栅格系统主要是用来布局页面的，他将一个页面均分为12份 4.angularjs特点 mvc开发思想，模块化开发 依赖注入 数据的双向绑定 5.深浅拷贝的区别 浅拷贝只是对一块内存增加了一个指针，访问这个变量依然还是访问的这块内存，而深拷贝是重新申请了一块内存，将另外一个内存的内容复制一份 6.怎么理解盒子模型？ 也叫框模型，是css技术使用的一种思维模型每个元素都可以看作一个盒子，每个元素都包含border.margin.paddingcontent,而盒子模型分为两种，一种是w3c标准盒子模型，另一种是IE盒子模型，和w3c不同的是ie盒子模型的content包含了border和padding 7.闭包 函数套用函数，内部函数访问外部变量，使其内的变量不会在函数执行完后被销毁简单来说就是 定义在函数内部的函数用途：可以读取函数的内部变量；二是可以将函数内的变量一直存在在内存中不被销毁 8.angular模块之间的通讯方式？ rootscope service 广播 9.什么是DTD？ 文档类型定义的简称，是程序间数据交换定义的语法规则 10.js中有哪些数据类型 ES5:Number Null Undefined String Array Function Object 11.addEventListen和onClick的区别？ onclick同一多次绑定本事件会被下面的覆盖掉，默认冒泡addEventListen会依次执行，可以在函数后的参数自定义为冒泡还是捕获，默认为冒泡 12.JS中快速复制数组的方法?12345var arr = [1, 2, 3];var arr1 = arr.slice(0);//或者var arr = [1, 2, 3];var arr1 = arr.concat(); 13.本地存储有哪些方式？ localStorage sessionStorage cookie indexedDB websql五种方式 14.请说出三种减少页面加载时间的方法? (1).小图片使用雪碧图的方式。大一点的用base64的方式。大直接加载(2).将上线代码进行合并、压缩、混淆(3).css放在文件头部，js放在尾部 15.jQuery中的方法链是什么？使用方法链有什么好处？ 就是对同一个对象的操作可以在上一步操作的后面接着写，好处是让代码看起来更简洁，可读性也高 code 持续更新中...","tags":[{"name":"web前端面试","slug":"web前端面试","permalink":"http://yoursite.com/tags/web前端面试/"}]},{"title":"各种算法实现","date":"2017-02-04T01:12:14.230Z","path":"2017/02/04/algorithm/","text":"去重算法 去除数组中的重复元素 1234567891011121314151617function delRepeat(arr)&#123; var newArray=new Array(); var len=arr.length; for(var i=0;i&lt;len;i++)&#123; for(var j=i+1;j&lt;len;j++) &#123; if(arr[i]==arr[j]) &#123; ++i; &#125; &#125; newArray.push(arr[i]); &#125; return newArray;&#125;var arr=new Array(&quot;red&quot;,&quot;red&quot;,&quot;1&quot;,&quot;5&quot;,&quot;2&quot;);alert(delRepeat(arr)); 二分算法，又称折半算法123456789101112131415161718function binaryInsertSort(arr)&#123; for (var i = 1; i &lt; arr.length; i++) &#123; var key = arr[i], left = 0, right = i - 1; while (left &lt;= right) &#123; var middle = parseInt((left + right) / 2); if (key &lt; arr[middle]) &#123; right = middle - 1; &#125; else &#123; left = middle + 1; &#125; &#125; for (var j = i - 1; j &gt;= left; j--) &#123; arr[j + 1] = arr[j]; &#125; arr[left] = key; &#125;return arr;&#125; 选择排序算法 选择排序就是通过n-i次关键字间的比较，从n-i-1个记录中选出关键字最小的记录，并和第i个记录进行交换。选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 1234567891011121314function selectSort(arr)&#123; for(var i = 0; i &lt; arr.length - 1; i++)&#123; var min = arr[i]; for(var j = i + 1; j &lt; arr.length - 1; j++)&#123; if(min &gt; arr[j])&#123; var temp = min; min = arr[j]; arr[j] = temp; &#125; &#125; arr[i] = min; &#125; return arr; &#125; 冒泡排序算法 冒泡排序是一种交换排序，它的基本思想是：两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端 1234567891011121314151617181920212223function bubbleSort(arr) &#123; var len = arr.length; for (var i = 0; i &lt; len - 1; i++) &#123; var n = 0; for (var j = 0; j &lt; len - i ; j++) &#123; if(arr[j] &lt; arr[j-1])&#123; n++; console.log(n); var temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp; &#125; &#125; if( n &lt; 1)&#123; break; &#125; &#125; return arr; &#125; 快速排序算法 （1）在数据集之中，选择一个元素作为”基准”（pivot）。（2）所有小于”基准”的元素，都移到”基准”的左边；所有大于”基准”的元素，都移到”基准”的右边。（3）对”基准”左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 12345678910111213141516function quickSort(arr)&#123; if (arr.length &lt;= 1)&#123;return arr&#125;; var pivotIndex = Math.floor(arr.length / 2); var pivot = arr.splice(pivotIndex,1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++)&#123; if(arr[i] &lt; pivot) &#123; left.push(arr[i]); &#125;else&#123; right.push(arr[i]); &#125; &#125; return quickSort(left).concat([pivot],quickSort(right)); &#125;","tags":[{"name":"算法 排序 快速排序 去重 二分搜索 选择排序","slug":"算法-排序-快速排序-去重-二分搜索-选择排序","permalink":"http://yoursite.com/tags/算法-排序-快速排序-去重-二分搜索-选择排序/"}]}]